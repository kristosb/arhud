{"version":3,"sources":["Components/Viewer/threejs/SceneSubject.js","Components/Viewer/threejs/GeneralLights.js","Components/Viewer/threejs/StereoCamera.js","Components/Viewer/threejs/StereoEffect.js","Components/Viewer/threejs/Hud.js","Components/Viewer/threejs/SceneManager.js","Components/Viewer/threejs/threeEntryPoint.js","Components/Viewer/Viewer.js","App.js","reportWebVitals.js","index.js"],"names":["scene","group","THREE","boxGeometry","boxGeometrySmall","makeInstance","geometry","color","x","y","z","material","cube","add","position","rotation","Math","PI","update","time","light","set","_eyeRight","Matrix4","_eyeLeft","offsetView","StereoCamera","this","type","aspect","eyeSep","offset","cameraL","PerspectiveCamera","layers","enable","matrixAutoUpdate","cameraR","_cache","focus","fov","near","far","zoom","camera","cache","xmin","xmax","projectionMatrix","clone","eyeSepHalf","eyeSepOnProjection","ymax","tan","MathUtils","DEG2RAD","elements","identity","setPosition","copy","multiply","matrixWorld","StereoEffect","renderer","_stereo","size","Vector2","getSize","setEyeSeparation","setOffset","setSize","width","height","render","updateMatrixWorld","parent","autoClear","clear","setScissorTest","setScissor","setViewport","hud","canvas","needsUpdate","side","transparent","planeGeometry","plane","clock","screenDimensions","mousePosition","background","buildScene","antialias","alpha","DPR","window","devicePixelRatio","setPixelRatio","gammaInput","gammaOutput","buildRender","aspectRatio","buildCamera","sceneSubjects","GeneralLights","SceneSubject","createSceneSubjects","effect","console","log","Hud","tanFOV","windowHeight","addEventListener","ev","keycode","which","elapsedTime","getElapsedTime","i","length","onWindowResize","atan","updateProjectionMatrix","onMouseMove","Viewer","container","document","createElement","appendChild","createCanvas","sceneManager","SceneManager","resizeCanvas","style","offsetWidth","offsetHeight","round","onresize","requestAnimationFrame","threeEntryPoint","threeRootElement","className","ref","element","Component","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.d4035f2e.chunk.js","sourcesContent":["import * as THREE from 'three'\n\nexport default function scene(scene) {    \n    const group = new THREE.Group();\n    const boxGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);\n    const boxGeometrySmall = new THREE.BoxGeometry(0.00002, 0.00002, 0.00002);\n    function makeInstance(geometry, color, x,y,z) {\n        const material = new THREE.MeshPhongMaterial({color});\n    \n        const cube = new THREE.Mesh(geometry, material);\n        scene.add(cube);\n        \n        //cube.rotation.x = 0.2;\n        cube.position.x = x;\n        cube.position.y = y;\n        cube.position.z = z;\n        \n        return cube;\n      }\n    const cubes = [\n    makeInstance(boxGeometry, 0x44aa88,  0, 0, -0.15),\n    makeInstance(boxGeometrySmall, 0xff0000,  -0.032, 0, -0.0002),\n    makeInstance(boxGeometrySmall, 0x00ff00,  0.032, 0, -0.0002)\n      ];\n    //group.add(boxGeometry);\n    //scene.add(group);\n\n\n    group.rotation.z = Math.PI/4;\n\n    const speed = 0.5;\n    const textureOffsetSpeed = 0.02;\n\n    function deformGeometry(geometry) {\n        /*for (let i=0; i<geometry.vertices.length; i+=2) {\n            const scalar = 1 + Math.random()*0.8;\n            geometry.vertices[i].multiplyScalar(scalar)\n        }*/\n\n        return geometry;\n    }\n\n    function update(time) {\n        const angle = time*speed;\n\n        //group.rotation.y = angle;\n        //cubes[0].rotation.x = angle;\n        //cubes[0].rotation.y = angle;\n        //subjectMaterial.alphaMap.offset.y = 0.55 + time * textureOffsetSpeed;\n\n        //subjectWireframe.material.color.setHSL( Math.sin(angle*2), 0.5, 0.5 );\n        \n        //const scale = (Math.sin(angle*8)+6.4)/5;\n        //subjectWireframe.scale.set(scale, scale, scale)\n    }\n\n    return {\n        update\n    }\n}","import * as THREE from 'three'\n\n\nexport default function scene(scene) {    \n\n    /*const lightIn = new THREE.PointLight(\"#4CAF50\", 30);\n    const lightOut = new THREE.PointLight(\"#2196F3\", 10);\n    lightOut.position.set(40,20,40);*/\n    const color = 0xFFFFFF;\n    const intensity = 1;\n    const light = new THREE.DirectionalLight(color, intensity);\n    //light.position.set(-1, 2, 4);\n    light.position.set(-1, 2, 4);\n    scene.add(light);\n    //scene.add(lightIn);\n    //scene.add(lightOut);\n    \n    //const rad = 80;\n\n    function update(time) {\n        //const x = rad * Math.sin(time*0.2)\n        //lightOut.position.x = x;\n    }\n\n    return {\n        update\n    }\n}","import { Matrix4 } from 'three/src/math/Matrix4.js';\nimport { MathUtils } from 'three/src/math/MathUtils.js';\nimport { PerspectiveCamera } from 'three/src/cameras/PerspectiveCamera.js';\n\nconst _eyeRight = new Matrix4();\nconst _eyeLeft = new Matrix4();\nconst offsetView = new Matrix4();\nclass StereoCamera {\n\n\tconstructor() {\n\n\t\tthis.type = 'StereoCamera';\n\n\t\tthis.aspect = 1;\n\n\t\tthis.eyeSep = 0.064;\n\n        this.offset = 0;\n        \n\t\tthis.cameraL = new PerspectiveCamera();\n\t\tthis.cameraL.layers.enable( 1 );\n\t\tthis.cameraL.matrixAutoUpdate = false;\n\n\t\tthis.cameraR = new PerspectiveCamera();\n\t\tthis.cameraR.layers.enable( 2 );\n\t\tthis.cameraR.matrixAutoUpdate = false;\n\n\t\tthis._cache = {\n\t\t\tfocus: null,\n\t\t\tfov: null,\n\t\t\taspect: null,\n\t\t\tnear: null,\n\t\t\tfar: null,\n\t\t\tzoom: null,\n\t\t\teyeSep: null,\n            offset: null\n\t\t};\n\t}\n\n\tupdate( camera ) {\n\n\t\tconst cache = this._cache;\n\n\t\tconst needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||\n\t\t\tcache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||\n\t\t\tcache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep || cache.offset !== this.offset;;\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tcache.focus = camera.focus;\n\t\t\tcache.fov = camera.fov;\n\t\t\tcache.aspect = camera.aspect * this.aspect;\n\t\t\tcache.near = camera.near;\n\t\t\tcache.far = camera.far;\n\t\t\tcache.zoom = camera.zoom;\n\t\t\tcache.eyeSep = this.eyeSep;\n            cache.offset = this.offset;\n\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\tconst projectionMatrix = camera.projectionMatrix.clone();\n\t\t\tconst eyeSepHalf = cache.eyeSep / 2;\n\t\t\tconst eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;\n\t\t\tconst ymax = ( cache.near * Math.tan( MathUtils.DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;\n\t\t\tlet xmin, xmax;\n\n\t\t\t// translate xOffset\n\n\t\t\t_eyeLeft.elements[ 12 ] = - eyeSepHalf;\n\t\t\t_eyeRight.elements[ 12 ] = eyeSepHalf;\n\n\t\t\t// for left eye\n\n\t\t\txmin = - ymax * cache.aspect + eyeSepOnProjection;\n\t\t\txmax = ymax * cache.aspect + eyeSepOnProjection;\n\n\t\t\tprojectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );\n\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n            var xminFixed = - ymax  + eyeSepOnProjection;\n\t\t\tvar xmaxFixed = ymax + eyeSepOnProjection;\n\n            offsetView.identity();\n            offsetView.setPosition(this._cache.offset,0,0);\n            offsetView.copy(offsetView.multiply(projectionMatrix));\n\n            this.cameraL.projectionMatrix.copy( offsetView );\n\t\t\t// for right eye\n\n\t\t\txmin = - ymax * cache.aspect - eyeSepOnProjection;\n\t\t\txmax = ymax * cache.aspect - eyeSepOnProjection;\n\n\t\t\tprojectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );\n\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n            xminFixed = - ymax  + eyeSepOnProjection;\n\t\t\txmaxFixed = ymax + eyeSepOnProjection;\n\n            offsetView.identity();\n            offsetView.setPosition(-this._cache.offset,0,0);\n            offsetView.copy(offsetView.multiply(projectionMatrix));\n\n\t\t\tthis.cameraR.projectionMatrix.copy( offsetView );\n\n\t\t}\n\n\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );\n\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );\n        \n\t}\n\n}\n\nexport { StereoCamera };","/*import {\n\tStereoCamera,\n\tVector2\n} from 'three/build/three.module.js';*/\nimport {\n\tVector2\n} from 'three/build/three.module.js';\n\nimport {StereoCamera} from \"./StereoCamera.js\"\n\nvar StereoEffect = function ( renderer ) {\n\n\tvar _stereo = new StereoCamera();\n\t_stereo.aspect = 0.5;\n\tvar size = new Vector2();\n\n    renderer.getSize( size );\n\n\tthis.setEyeSeparation = function ( eyeSep ) {\n\n\t\t_stereo.eyeSep = eyeSep;\n\n\t};\n    this.setOffset = function ( offset ) {\n\n\t\t_stereo.offset = offset;\n\n\t};\n\n\tthis.setSize = function ( width, height ) {\n\n\t\trenderer.setSize( width, height );\n\n\t};\n\n\tthis.render = function ( scene, camera ) {\n\t\tscene.updateMatrixWorld();\n\n\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n        \n\t\t_stereo.update( camera );\n        \n\t\trenderer.getSize( size );\n        \n\t\tif ( renderer.autoClear ) renderer.clear();\n\t\trenderer.setScissorTest( true );\n\n\t\trenderer.setScissor( 0, 0, size.width / 2, size.height );\n\t\trenderer.setViewport( 0, 0, (size.width / 2), size.height );\n\t\trenderer.render( scene, _stereo.cameraL );\n\n\t\trenderer.setScissor( (size.width / 2), 0, size.width / 2, size.height );\n\t\trenderer.setViewport( (size.width / 2), 0, (size.width / 2), size.height );\n\t\trenderer.render( scene, _stereo.cameraR );\n\n\t\trenderer.setScissorTest( false );\n        \n\t};\n\n};\n\nexport { StereoEffect };","import * as THREE from 'three'\n\nexport default function hud(scene,canvas){\n    \n    const screenDimensions = {\n        width: canvas.width,\n        height: canvas.height\n    }\n    var hudTexture = new THREE.Texture(canvas);\n    hudTexture.needsUpdate = true;\n    var material = new THREE.MeshBasicMaterial( {color: 0xffff00, side: THREE.DoubleSide} );\n    material.transparent = true;\n    var planeGeometry = new THREE.PlaneGeometry( 0.4, 0.4 );\n    var plane = new THREE.Mesh( planeGeometry, material );\n    plane.position.set(0,0,-0.15);\n    scene.add( plane );\n\n\tfunction update(time) {\n\n    }\n\n    return {\n        update,\n    }\n}","import * as THREE from 'three';\nimport SceneSubject from './SceneSubject';\nimport GeneralLights from './GeneralLights';\nimport { StereoEffect } from './StereoEffect.js';\nimport Hud from './Hud';\n\nexport default function canvas(canvas)  {\n    var preserveSize = true;\n\n    const clock = new THREE.Clock();\n    const origin = new THREE.Vector3(0,0,0);\n\n    const screenDimensions = {\n        width: canvas.width,\n        height: canvas.height\n    }\n    \n    const mousePosition = {\n        x: 0,\n        y: 0\n    }\n\n    const scene = buildScene();\n    const renderer = buildRender(screenDimensions);\n    const camera = buildCamera(screenDimensions);\n    const sceneSubjects = createSceneSubjects(scene);\n\n    var effect = new StereoEffect( renderer );\n    effect.setSize( screenDimensions.width, screenDimensions.height );\n    effect.setEyeSeparation(0.064);\n    effect.setOffset(0);\n    var offset = 0;\n    scene.add(camera);\n    console.log(screenDimensions);\n    var hud = new Hud(scene,canvas);\n    if (preserveSize){\n        // remember these initial values\n        var tanFOV = Math.tan( ( ( Math.PI / 180 ) * camera.fov / 2 ) );\n        var windowHeight = 150;//window.innerHeight;\n    }\n    window.addEventListener(\"keypress\", onKeyPress);\n\n    function getOffset(){\n        const pxMm = 0.254/454;\n        return (screenDimensions.width -300)*pxMm;\n    }\n    function buildScene() {\n        const scene = new THREE.Scene();\n        scene.background = new THREE.Color('black');\n\n        return scene;\n    }\n\n    function buildRender({ width, height }) {\n        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true }); \n        const DPR = window.devicePixelRatio ? window.devicePixelRatio : 1;\n\n        renderer.setPixelRatio(DPR);\n        renderer.setSize(width, height);\n        renderer.autoClear = false;     //needed for canvas2d overlayed\n        renderer.gammaInput = true;\n        renderer.gammaOutput = true; \n        \n        return renderer;\n    }\n\n    function buildCamera({ width, height }) {\n        const aspectRatio = width / height;\n        const fieldOfView = 90;\n        const nearPlane = 0.0001;\n        const farPlane = 20; \n        const camera = new THREE.PerspectiveCamera(fieldOfView, aspectRatio, nearPlane, farPlane);\n        camera.focus = 3;\n        camera.position.set(0, 0, 0);\n\n        return camera;\n    }\n\n    function createSceneSubjects(scene) {\n        const sceneSubjects = [\n            new GeneralLights(scene),\n            new SceneSubject(scene),\n        ];\n        return sceneSubjects;\n    }\n\n\n    function update() {\n        const elapsedTime = clock.getElapsedTime();\n\n        for(let i=0; i<sceneSubjects.length; i++)\n            sceneSubjects[i].update(elapsedTime);\n        //renderer.render(scene, camera);\n        render();\n    }\n    function render() {\n        //updateCameraPositionRelativeToMouse()\n        effect.render( scene, camera );\n    }\n    function onKeyPress(ev) {\n        let keycode = ev.which;\n        if (\n          (keycode >= 48 && keycode <= 57) ||\n          (keycode >= 97 && keycode <= 122) ||\n          (keycode >= 65 && keycode <= 90)\n        ) {\n            if(keycode == 49) {offset= offset +0.1;effect.setOffset(offset);}\n            if(keycode == 50) {offset = offset -0.1;effect.setOffset(offset);}\n            //if(keycode == 51) {camera.rotateY(Math.PI/360);}\n            //if(keycode == 52) {camera.rotateY(-Math.PI/360);}\n            console.log( offset);\n        }\n      }\n\n\n    function updateCameraPositionRelativeToMouse() {\n        camera.position.x += (  (mousePosition.x * 0.1) - camera.position.x ) * 0.1;\n        camera.position.y += ( -(mousePosition.y * 0.1) - camera.position.y ) * 0.1;\n        camera.lookAt(origin );\n    }\n\n    function onWindowResize() {\n        const { width, height } = canvas;\n        \n        screenDimensions.width = width;\n        screenDimensions.height = height;\n\n        camera.aspect = width / height;\n        if (preserveSize){\n            // adjust the FOV\n            camera.fov = ( 360 / Math.PI ) * Math.atan( tanFOV * ( height / windowHeight ) );\n            effect.setOffset(getOffset());\n        }\n\n        camera.updateProjectionMatrix();\n        effect.setSize( width, height);\n        //camera.lookAt( scene.position );\n        renderer.setSize(width, height);   \n    }\n\n    function onMouseMove(x, y) {\n        mousePosition.x = x;\n        mousePosition.y = y;\n    }\n\n    return {\n        update,\n        onWindowResize,\n        onMouseMove\n    }\n}","import SceneManager from './SceneManager';\n\nexport default container => {\n    \n    const canvas = createCanvas(document, container);\n    //const canvas2d = createCanvas2d(document, container);\n    const sceneManager = new SceneManager(canvas);\n    //const hudManager = new HudManager(sceneManager.rendererGet());\n\n    let canvasHalfWidth;\n    let canvasHalfHeight;\n\n\n    bindEventListeners();\n    render();\n    \n    function createCanvas(document, container) {\n        const canvas = document.createElement(\"canvas\");    \n        container.appendChild(canvas);   \n        return canvas;\n    }\n\n    function bindEventListeners() {\n        window.onresize = resizeCanvas;\n        //window.onmousemove = mouseMove;\n        resizeCanvas();\t\n    }\n\n    function resizeCanvas() {        \n        canvas.style.width = '100%';\n        canvas.style.height= '100%';\n        \n        canvas.width  = canvas.offsetWidth;\n        canvas.height = canvas.offsetHeight;\n\n\n\n\n        canvasHalfWidth = Math.round(canvas.offsetWidth/2);\n        canvasHalfHeight = Math.round(canvas.offsetHeight/2);\n\n        sceneManager.onWindowResize();\n        //hudManager.onWindowResize()\n    }\n\n    function mouseMove({screenX, screenY}) {\n        sceneManager.onMouseMove(screenX-canvasHalfWidth, screenY-canvasHalfHeight);\n    }\n\n    function render(time) {\n        \n        sceneManager.update();\n        //hudManager.update();\n        requestAnimationFrame(render);\n    }\n}\n/*\nimport * as THREE from 'three';\nimport { StereoEffect } from 'three/examples/jsm/effects/StereoEffect.js';\nexport default container => {\n    const canvas = createCanvas(document, container);\n    var scene = new THREE.Scene();\n  \n    // Create shortcuts for window size.\n    var width = window.innerWidth;\n    var height = window.innerHeight;\n    // Create camera and move it a bit further. Make it to look to origo.\n    var camera = new THREE.PerspectiveCamera( 75, width / height, 0.001, 50 );\n    camera.position.y = 0;\n    camera.position.z = 0;\n    camera.position.x = 0;\n      //camera.lookAt(scene.position);\n    \n    // Create renderer.\n    var renderer = new THREE.WebGLRenderer({antialias: true});\n      renderer.setSize( width, height );\n    renderer.autoClear = false;\n    //document.body.appendChild(renderer.domElement);\n    var effect = new StereoEffect( renderer );\n    effect.setSize( width, height );\n    effect.eyeSeparation = 0.064;\n\n    container.appendChild(renderer.domElement);\n  \n    // Let there be light!\n    var light = new THREE.DirectionalLight( 0xffffff, 1 );\n      light.position.set( -1, 2, 4 );\n      scene.add(light);\n  \n    // And the box.\n    var geometry = new THREE.BoxGeometry( 0.1, 0.1, 0.1 );\n    var material = new THREE.MeshPhongMaterial( {color: 0xcccccc} );\n    var cube = new THREE.Mesh( geometry, material );\n    cube.position.set(0,0,-0.25);\n    scene.add( cube );\n  \n  \n    \n    \n    // Ok, now we have the cube. Next we'll create the hud. For that we'll\n    // need a separate scene which we'll render on top of our 3D scene. We'll\n    // use a dynamic texture to render the HUD.\n    \n    // We will use 2D canvas element to render our HUD.  \n    //var hudCanvas = canvas;//document.createElement('canvas');\n    \n    // Again, set dimensions to fit the screen.\n    canvas.width = width;\n    canvas.height = height;\n  \n    // Get 2D context and draw something supercool.\n    var hudBitmap = canvas.getContext('2d');\n      hudBitmap.font = \"Normal 60px Arial\";\n    hudBitmap.textAlign = 'start';\n    hudBitmap.fillStyle = \"rgba(245,0,0,0.75)\";\n    hudBitmap.fillText('Initializing......................12345378', 0 , height/2 );\n    //hudBitmap.scale(0.1,0.1);\n    //console.log(hudBitmap.position);  \n    //console.log(cube.position); \n    // Create the camera and set the viewport to match the screen dimensions.\n    //var cameraHUD = new THREE.OrthographicCamera(-width/2, width/2, height/2, -height/2, 0, 500 );\n    //var cameraHUD = new THREE.PerspectiveCamera( 45, width / height, 0.005, 50 );\n    //cameraHUD.position.y = 100;\n    //cameraHUD.position.z = 1;\n    //cameraHUD.position.x = 100;\n    //cameraHUD.lookAt(scene.position);\n    //var cameraHUD = new THREE.OrthographicCamera(-width*2, width*2, height*2, -height*2, 0, 500 );\n \n\n\n    // Create also a custom scene for HUD.\n    //var sceneHUD = scene;//new THREE.Scene();\n    //cameraHUD.lookAt(sceneHUD.position);\n      // Create texture from rendered graphics.\n      var hudTexture = new THREE.Texture(canvas);\n      hudTexture.needsUpdate = true;\n    \n    // Create HUD material.\n    var material = new THREE.MeshBasicMaterial( {map: hudTexture, side: THREE.DoubleSide} );\n    material.transparent = true;\n    \n    // Create plane to render the HUD. This plane fill the whole screen.\n    var planeGeometry = new THREE.PlaneGeometry( width/3000, height/3000 );\n    var plane = new THREE.Mesh( planeGeometry, material );\n    plane.position.set(0,0,-0.15);\n    //plane.scale.set(0.00035,0.0035,0.00035);\n    scene.add( plane );\n    \n    //console.log(canvas.width);\n    //console.log(hudCanvas.width );\n    \n    \n    // Now we have two scenes. Only thing we need now is a render loop!\n    function animate() {\n      \n      // Rotate cube.\n      cube.rotation.x += 0.01;\n      cube.rotation.y -= 0.01;\n      cube.rotation.z += 0.03;\n  \n      // Update HUD graphics.\n      //hudBitmap.clearRect(0, 0, width, height);\n      //hudBitmap.fillText(\"RAD [x:\"+(cube.rotation.x % (2 * Math.PI)).toFixed(1)+\", y:\"+(cube.rotation.y % (2 * Math.PI)).toFixed(1)+\", z:\"+(cube.rotation.z % (2 * Math.PI)).toFixed(1)+\"]\" , width / 2, height /2);\n \n      //hudTexture.needsUpdate = true;\n      \n      // Render scene.\n      //renderer.render(scene, camera);\n      effect.render(scene, camera);\n      // Render HUD on top of the scene.\n      //renderer.render(sceneHUD, cameraHUD);\n      //effect.render(sceneHUD, camera);\n       // effect.render(sceneHUD, cameraHUD);\n      // Request new frame.\n      requestAnimationFrame(animate);\n  \n    };\n    //\n    // Start animation.\n    \n    animate();\n    bindEventListeners();\n\n    let canvasHalfWidth;\n    let canvasHalfHeight;\n    \n    \n    //render();\n    \n\n\n    function createCanvas(document, container) {\n        const canvas = document.createElement(\"canvas\");    \n        //container.appendChild(canvas);   \n        return canvas;\n    }\n\n\n    function bindEventListeners() {\n        window.onresize = resizeCanvas;\n        //window.onmousemove = mouseMove;\n        resizeCanvas();\t\n    }\n\n    function resizeCanvas() {     \n        canvas.style.width = '100%';\n        canvas.style.height= '100%';\n        canvas.width  = window.innerWidth;\n        canvas.height = window.innerHeight;\n\n\n        camera.aspect = canvas.width / canvas.height;\n        camera.updateProjectionMatrix();\n\n        effect.setSize( canvas.width, canvas.height);\n        //canvasHalfWidth = Math.round(canvas.offsetWidth/2);\n        //canvasHalfHeight = Math.round(canvas.offsetHeight/2);\n\n    }\n\n\n\n}*/","import React, { Component } from 'react';\n\nimport threeEntryPoint from \"./threejs/threeEntryPoint\"\nimport \"./viewer.css\"\n\nexport default class Viewer extends Component {\n    \n    componentDidMount() {\n        threeEntryPoint(this.threeRootElement);\n    }\n\n    render () {\n        return (\n            <div className=\"viewer-viewer\" ref={element => this.threeRootElement = element} />\n        );\n    }\n}","import './App.css';\nimport Viewer from './Components/Viewer/Viewer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Viewer />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}