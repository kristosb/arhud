{"version":3,"sources":["Components/Viewer/threejs/SceneSubject.js","Components/Viewer/threejs/GeneralLights.js","Components/Viewer/threejs/StereoCamera.js","Components/Viewer/threejs/StereoEffect.js","Components/Viewer/threejs/HudControls.js","Components/Viewer/threejs/Hud.js","Components/Viewer/threejs/SceneManager.js","Components/Viewer/threejs/threeEntryPoint.js","Components/Viewer/Viewer.js","App.js","reportWebVitals.js","index.js"],"names":["scene","group","THREE","boxGeometry","boxGeometrySmall","makeInstance","geometry","color","x","y","z","material","cube","add","position","cubes","rotation","Math","PI","update","time","angle","light","set","_eyeRight","Matrix4","_eyeLeft","offsetView","StereoCamera","this","type","aspect","eyeSep","offset","cameraL","PerspectiveCamera","layers","enable","matrixAutoUpdate","cameraR","_cache","focus","fov","near","far","zoom","camera","cache","xmin","xmax","projectionMatrix","clone","eyeSepHalf","eyeSepOnProjection","ymax","tan","MathUtils","DEG2RAD","elements","identity","setPosition","copy","multiply","matrixWorld","StereoEffect","renderer","_stereo","size","Vector2","getSize","setEyeSeparation","setOffset","setSize","width","height","render","updateMatrixWorld","parent","autoClear","clear","setScissorTest","setScissor","setViewport","hudControl","bm","_x","_y","lineWidth","globalLineWidth","localLineWidth","hudSimpleText","txt","font","textAlign","fillText","hudBorder","strokeRect","crosshair","floor","strokeWidth","beginPath","moveTo","lineTo","closePath","stroke","hud","canvas","screenDimensions","console","log","now","then","window","innerHeight","style","hudCanvas","document","createElement","hudBitmap","getContext","fillStyle","strokeStyle","globalAlpha","hudElements","info","HUD","border","Object","values","forEach","val","draw","hudTexture","needsUpdate","map","transparent","planeGeometry","plane","name","vx","vy","clearRect","d","Date","text","getHours","getMinutes","getSeconds","getCanvas","clock","mousePosition","background","buildScene","antialias","alpha","DPR","devicePixelRatio","setPixelRatio","gammaInput","gammaOutput","buildRender","aspectRatio","buildCamera","sceneSubjects","GeneralLights","SceneSubject","createSceneSubjects","Hud","effect","tanFOV","windowHeight","elapsedTime","getElapsedTime","i","length","addEventListener","ev","keycode","which","onWindowResize","atan","updateProjectionMatrix","onMouseMove","getRenderer","animate","setAnimationLoop","getScene","Viewer","container","appendChild","createCanvas","sceneManager","SceneManager","resizeCanvas","offsetWidth","offsetHeight","round","onresize","threeEntryPoint","threeRootElement","className","ref","element","Component","App","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.5b20a127.chunk.js","sourcesContent":["import * as THREE from 'three'\n\nexport default function scene(scene) {    \n    const group = new THREE.Group();\n    const boxGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);\n    const boxGeometrySmall = new THREE.BoxGeometry(0.00002, 0.00002, 0.00002);\n    function makeInstance(geometry, color, x,y,z) {\n        const material = new THREE.MeshPhongMaterial({color});\n    \n        const cube = new THREE.Mesh(geometry, material);\n        scene.add(cube);\n        \n        //cube.rotation.x = 0.2;\n        cube.position.x = x;\n        cube.position.y = y;\n        cube.position.z = z;\n        \n        return cube;\n      }\n    const cubes = [\n    makeInstance(boxGeometry, 0x44aa88,  0, 0, -0.5),\n    makeInstance(boxGeometrySmall, 0xff0000,  -0.032, 0, -0.0002),\n    makeInstance(boxGeometrySmall, 0x00ff00,  0.032, 0, -0.0002)\n      ];\n    //group.add(boxGeometry);\n    //scene.add(group);\n\n\n    group.rotation.z = Math.PI/4;\n\n    const speed = 0.5;\n    const textureOffsetSpeed = 0.02;\n\n    function deformGeometry(geometry) {\n        /*for (let i=0; i<geometry.vertices.length; i+=2) {\n            const scalar = 1 + Math.random()*0.8;\n            geometry.vertices[i].multiplyScalar(scalar)\n        }*/\n\n        return geometry;\n    }\n\n    function update(time) {\n        const angle = time*speed;\n\n        //group.rotation.y = angle;\n        cubes[0].rotation.x = angle;\n        cubes[0].rotation.y = angle;\n        //subjectMaterial.alphaMap.offset.y = 0.55 + time * textureOffsetSpeed;\n\n        //subjectWireframe.material.color.setHSL( Math.sin(angle*2), 0.5, 0.5 );\n        \n        //const scale = (Math.sin(angle*8)+6.4)/5;\n        //subjectWireframe.scale.set(scale, scale, scale)\n    }\n\n    return {\n        update\n    }\n}","import * as THREE from 'three'\n\n\nexport default function scene(scene) {    \n\n    /*const lightIn = new THREE.PointLight(\"#4CAF50\", 30);\n    const lightOut = new THREE.PointLight(\"#2196F3\", 10);\n    lightOut.position.set(40,20,40);*/\n    const color = 0xFFFFFF;\n    const intensity = 1;\n    const light = new THREE.DirectionalLight(color, intensity);\n    //light.position.set(-1, 2, 4);\n    light.position.set(-1, 2, 4);\n    scene.add(light);\n    //scene.add(lightIn);\n    //scene.add(lightOut);\n    \n    //const rad = 80;\n\n    function update(time) {\n        //const x = rad * Math.sin(time*0.2)\n        //lightOut.position.x = x;\n    }\n\n    return {\n        update\n    }\n}","import { Matrix4 } from 'three/src/math/Matrix4.js';\nimport { MathUtils } from 'three/src/math/MathUtils.js';\nimport { PerspectiveCamera } from 'three/src/cameras/PerspectiveCamera.js';\n\nconst _eyeRight = new Matrix4();\nconst _eyeLeft = new Matrix4();\nconst offsetView = new Matrix4();\nclass StereoCamera {\n\n\tconstructor() {\n\n\t\tthis.type = 'StereoCamera';\n\n\t\tthis.aspect = 1;\n\n\t\tthis.eyeSep = 0.064;\n\n        this.offset = 0;\n        \n\t\tthis.cameraL = new PerspectiveCamera();\n\t\tthis.cameraL.layers.enable( 1 );\n\t\tthis.cameraL.matrixAutoUpdate = false;\n\n\t\tthis.cameraR = new PerspectiveCamera();\n\t\tthis.cameraR.layers.enable( 2 );\n\t\tthis.cameraR.matrixAutoUpdate = false;\n\n\t\tthis._cache = {\n\t\t\tfocus: null,\n\t\t\tfov: null,\n\t\t\taspect: null,\n\t\t\tnear: null,\n\t\t\tfar: null,\n\t\t\tzoom: null,\n\t\t\teyeSep: null,\n            offset: null\n\t\t};\n\t}\n\n\tupdate( camera ) {\n\n\t\tconst cache = this._cache;\n\n\t\tconst needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||\n\t\t\tcache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||\n\t\t\tcache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep || cache.offset !== this.offset;;\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tcache.focus = camera.focus;\n\t\t\tcache.fov = camera.fov;\n\t\t\tcache.aspect = camera.aspect * this.aspect;\n\t\t\tcache.near = camera.near;\n\t\t\tcache.far = camera.far;\n\t\t\tcache.zoom = camera.zoom;\n\t\t\tcache.eyeSep = this.eyeSep;\n            cache.offset = this.offset;\n\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\tconst projectionMatrix = camera.projectionMatrix.clone();\n\t\t\tconst eyeSepHalf = cache.eyeSep / 2;\n\t\t\tconst eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;\n\t\t\tconst ymax = ( cache.near * Math.tan( MathUtils.DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;\n\t\t\tlet xmin, xmax;\n\n\t\t\t// translate xOffset\n\n\t\t\t_eyeLeft.elements[ 12 ] = - eyeSepHalf;\n\t\t\t_eyeRight.elements[ 12 ] = eyeSepHalf;\n\n\t\t\t// for left eye\n\n\t\t\txmin = - ymax * cache.aspect + eyeSepOnProjection;\n\t\t\txmax = ymax * cache.aspect + eyeSepOnProjection;\n\n\t\t\tprojectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );\n\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n            var xminFixed = - ymax  + eyeSepOnProjection;\n\t\t\tvar xmaxFixed = ymax + eyeSepOnProjection;\n\n            offsetView.identity();\n            offsetView.setPosition(this._cache.offset,0,0);\n            offsetView.copy(offsetView.multiply(projectionMatrix));\n\n            this.cameraL.projectionMatrix.copy( offsetView );\n\t\t\t// for right eye\n\n\t\t\txmin = - ymax * cache.aspect - eyeSepOnProjection;\n\t\t\txmax = ymax * cache.aspect - eyeSepOnProjection;\n\n\t\t\tprojectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );\n\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n            xminFixed = - ymax  + eyeSepOnProjection;\n\t\t\txmaxFixed = ymax + eyeSepOnProjection;\n\n            offsetView.identity();\n            offsetView.setPosition(-this._cache.offset,0,0);\n            offsetView.copy(offsetView.multiply(projectionMatrix));\n\n\t\t\tthis.cameraR.projectionMatrix.copy( offsetView );\n\n\t\t}\n\n\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );\n\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );\n        \n\t}\n\n}\n\nexport { StereoCamera };","/*import {\n\tStereoCamera,\n\tVector2\n} from 'three/build/three.module.js';*/\nimport {\n\tVector2\n} from 'three/build/three.module.js';\n\nimport {StereoCamera} from \"./StereoCamera.js\"\n\nvar StereoEffect = function ( renderer ) {\n\n\tvar _stereo = new StereoCamera();\n\t_stereo.aspect = 0.5;\n\tvar size = new Vector2();\n\n    renderer.getSize( size );\n\n\tthis.setEyeSeparation = function ( eyeSep ) {\n\n\t\t_stereo.eyeSep = eyeSep;\n\n\t};\n    this.setOffset = function ( offset ) {\n\n\t\t_stereo.offset = offset;\n\n\t};\n\n\tthis.setSize = function ( width, height ) {\n\n\t\trenderer.setSize( width, height );\n\n\t};\n\n\tthis.render = function ( scene, camera ) {\n\t\tscene.updateMatrixWorld();\n\n\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n        \n\t\t_stereo.update( camera );\n        \n\t\trenderer.getSize( size );\n        \n\t\tif ( renderer.autoClear ) renderer.clear();\n\t\trenderer.setScissorTest( true );\n\n\t\trenderer.setScissor( 0, 0, size.width / 2, size.height );\n\t\trenderer.setViewport( 0, 0, (size.width / 2), size.height );\n\t\trenderer.render( scene, _stereo.cameraL );\n\n\t\trenderer.setScissor( (size.width / 2), 0, size.width / 2, size.height );\n\t\trenderer.setViewport( (size.width / 2), 0, (size.width / 2), size.height );\n\t\trenderer.render( scene, _stereo.cameraR );\n\n\t\trenderer.setScissorTest( false );\n        \n\t};\n\n};\n\nexport { StereoEffect };"," class hudControl {\n     constructor(bm, x, y){\n        this.bm = bm;\n        this._x = x;\n        this._y = y;\n        this.lineWidth = this.bm.lineWidth;\n        this.globalLineWidth = this.bm.lineWidth;\n     }\n     set lineWidth(lineWidth){\n        this.localLineWidth = lineWidth;\n    }\n    set x(x){\n        this._x = x;\n    }\n    get x(){\n        return this._x;\n    }\n    set y(y){\n        this._y = y;\n    }\n    get y(){\n        return this._y;\n    }\n    changeLocalLineWidth(){\n        this.globalLineWidth = this.bm.lineWidth;\n        this.bm.lineWidth = this.localLineWidth;\n    }\n    resetGlobalLineWidth(){\n        this.bm.lineWidth = this.globalLineWidth;\n    }\n     draw(){\n\n     }\n }\n /*set x(xx){\n    this.x = xx;//Math.floor(xx) + 0.5;\n}\nset y(yy){\n    this.y = Math.floor(yy) + 0.5;\n}\nget x(){\n    return this.x;\n}\nget y(){\n    return this.y;\n}*/\n\nexport class hudSimpleText extends hudControl{\n    constructor(bm, x, y) {\n        super(bm,x,y);\n        this.txt = \"hello...\"\n    }\n    set text(txt){\n        this.txt = txt;\n    }\n    draw(){\n        this.bm.font = \"20px monaco\";\n        this.bm.textAlign = 'start';\n        this.bm.fillText(this.txt, this.x, this.y);\n    }\n  }\n\nexport class hudBorder extends hudControl{\n    constructor(bm, width, height) {\n        super(bm,0,0);\n        this.width = width;\n        this.height = height;\n    }  \n    draw(){\n        super.changeLocalLineWidth();\n        this.bm.strokeRect(0,0,this.width, this.height);\n        super.resetGlobalLineWidth();\n    }\n\n  }\n \nexport class crosshair extends hudControl{\n    constructor(bm, width, height) {\n        super(bm,width / 2,height / 2);\n        this.width = width;\n        this.height = height;\n\n    }\n\n    draw(){\n        // remove aliasing\n        this.x = Math.floor(this.x) + 0.5;\n        this.y = Math.floor(this.y) + 0.5;\n        super.changeLocalLineWidth();\n        this.bm.strokeWidth = 1;\n        this.bm.beginPath();\n        this.bm.moveTo(this.x, this.y - 10);\n        this.bm.lineTo(this.x, this.y + 10);\n        this.bm.moveTo(this.x - 10,  this.y);\n        this.bm.lineTo(this.x + 10,  this.y);\n        this.bm.closePath();\n        this.bm.stroke();\n        super.resetGlobalLineWidth();\n    }\n  }\n\n\n\n\n\nexport default {hudSimpleText, hudBorder, crosshair}\n","import * as THREE from 'three'\nimport * as HUD from './HudControls';\nexport default function hud(scene,canvas){\n    \n    const screenDimensions = {\n        width: canvas.width,\n        height: canvas.height\n    }\n    console.log(screenDimensions);\n    var count = 0;\n    var elapsed, now;\n    var then= 0;\n    var interval=0.1;\n    console.log('win'+window.innerHeight);\n    var style = `rgba(\n        ${0xa3},\n        ${0xff},\n        ${0x00},\n        ${0xFF}`;\n    var hudCanvas = document.createElement('canvas');\n    hudCanvas.width = screenDimensions.width/2; //keep it square assuming default 300x150\n    hudCanvas.height = screenDimensions.height;\n    var hudBitmap = hudCanvas.getContext('2d');\n    //flipHoriz(hudBitmap);    \n    hudBitmap.fillStyle = style;\n    hudBitmap.strokeStyle = style;\n    hudBitmap.globalAlpha = 0.75;\n    var hudElements = {\n        info: new HUD.hudSimpleText(hudBitmap, 10, 20),\n        border: new HUD.hudBorder(hudBitmap,hudCanvas.width,hudCanvas.height),\n        crosshair: new HUD.crosshair(hudBitmap,hudCanvas.width,hudCanvas.height)\n    };\n    hudElements.border.lineWidth = 5;\n    hudElements.crosshair.lineWidth = 2;\n    //hudElements.border.draw();\n    Object.values(hudElements).forEach(val => {val.draw()});\n    //hudBitmap.clearRect(0,0,300,300);\n    //HUD.animation(hudAnimate);\n    //animator.\n    /*var ball = {\n        x: 100,\n        y: 100,\n        vx: 5,\n        vy: 2,\n        radius: 25,\n        color: 'blue',\n        draw: function() {\n            hudBitmap.beginPath();\n            hudBitmap.arc(this.x, this.y, this.radius, 0, Math.PI * 2, true);\n            hudBitmap.closePath();\n            hudBitmap.fillStyle = this.color;\n            hudBitmap.fill();\n        }\n      };*/\n      \n\n      //ball.draw();  \n\n    var hudTexture = new THREE.Texture(hudCanvas);\n    //hudTexture.name = \"hudCanvas\";\n    hudTexture.needsUpdate = true;\n    var material = new THREE.MeshBasicMaterial({map: hudTexture} );//{color: 0xffff00, side: THREE.DoubleSide} );\n    material.transparent = true;\n    var planeGeometry = new THREE.PlaneGeometry( 0.4, 0.4 );\n    var plane = new THREE.Mesh( planeGeometry, material );\n    plane.name = \"hudPlane\";\n    plane.position.set(0,0,-0.15);\n    scene.add( plane );\n    var vx = 5;\n    var vy = 2;\n    //var count = 0;\n    function draw() {\n        hudBitmap.clearRect(0,0,screenDimensions.width/2,screenDimensions.height);\n        //count++;\n        var d = new Date();   \n        hudElements.info.text = `${d.getHours()}:${d.getMinutes()}:${d.getSeconds()}`;\n        \n        //hudTexture.needsUpdate = true;\n        //hudBitmap.clearRect(0,0, 300, 300);\n        hudElements.crosshair.x = hudElements.crosshair.x  +vx;\n        hudElements.crosshair.y = hudElements.crosshair.y  +vy;\n        if (hudElements.crosshair.y+ vy > screenDimensions.height || hudElements.crosshair.y + vy < 0) {\n            vy = -vy;\n          }\n        if (hudElements.crosshair.x + vx > screenDimensions.width/2 || hudElements.crosshair.x+ vx < 0) {\n            vx = -vx;\n        }\n        //hudElements.info.x= hudElements.crosshair.x-30;\n        //hudElements.info.y= hudElements.crosshair.y-30;\n        hudElements.info.draw();\n        hudElements.crosshair.draw();\n        hudTexture.needsUpdate = true;\n        //console.log(screenDimensions.width);\n        \n        //hudTexture.needsUpdate = true;\n        /*ball.draw();\n        ball.x += ball.vx;\n        ball.y += ball.vy;\n        if (ball.y + ball.vy > screenDimensions.height || ball.y + ball.vy < 0) {\n            ball.vy = -ball.vy;\n          }\n        if (ball.x + ball.vx > screenDimensions.width || ball.x + ball.vx < 0) {\n            ball.vx = -ball.vx;\n        }*/\n        //console.log(hudCanvas);\n        //var a =scene.getObjectByName(\"hudPlane\").material.map;\n        //console.log(a);\n        //console.log(scene.getObjectByName(\"hudPlane\").material.map.minimaps);\n        //console.log(scene.getObjectByName(\"hudPlane\").material.map.image);\n      }\n    //draw();\n    //draw();\n    //draw();\n    //draw();\n    //setInterval(draw, 5000);\n\n    \n      //canvas.addEventListener('mouseover', function(e) {\n        \n      //});\n      \n      //canvas.addEventListener('mouseout', function(e) {\n     //   window.cancelAnimationFrame(raf);\n      //});\n      \n      \n      //window.requestAnimationFrame(draw);\n    //hudAnimate();\n    /*function hudAnimate(){\n        hudBitmap.clearRect(0,0,300,300);\n        //hudCanvas.clearRect(0,0, hudCanvas.width, hudCanvas.height);\n        hudElements.info.text = count.toString();\n        Object.values(hudElements).forEach(val => {val.draw()});\n        count= count +1;\n        //console.log(\"anim\");\n        window.requestAnimationFrame(hudAnimate);\n    }*/\n    //window.requestAnimationFrame(hudAnimate);\n    //hudAnimate();\n///////////////////////\n/*var raf;\nvar stop = false;\nvar frameCount = 0;\n//this.$results = $(\"#results\");\nvar fps = 5; \nvar fpsInterval=1000/this.fps;\nvar startTime = 0;\nvar now = Date.now();\nvar then = Date.now();\nvar elapsed = 0;\n\n//startAnimating(1);\n//}\n//function startAnimating(fps) {\n    fps = 1;\n    fpsInterval = 1000 / fps;\n    then = Date.now();\n    startTime = then;\n    console.log(startTime);\n    \n//}\nfunction  animate( ){\n\n    // calc elapsed time since last loop\n\n    now = Date.now();\n    elapsed = now - then;\n\n    // if enough time has elapsed, draw the next frame\n    //console.log(\"noanim\");\n    if ( elapsed > fpsInterval) {\n\n        // Get ready for next frame by setting then=now, but...\n        // Also, adjust for fpsInterval not being multiple of 16.67\n        then = now - (elapsed % fpsInterval);\n\n        // draw stuff here\n\n        \n        // TESTING...Report #seconds since start and achieved fps.\n        //var sinceStart = this.now - this.startTime;\n        //var currentFps = Math.round(1000 / (sinceStart / ++this.frameCount) * 100) / 100;\n        //$results.text(\"Elapsed time= \" + Math.round(sinceStart / 1000 * 100) / 100 + \" secs @ \" + currentFps + \" fps.\");\n        //hudAnimate.call(scope);\n        hudBitmap.clearRect(0,0,300,300);\n        //hudCanvas.clearRect(0,0, hudCanvas.width, hudCanvas.height);\n        hudElements.info.text = count.toString();\n        Object.values(hudElements).forEach(val => {val.draw()});\n        count= count +1;\n        console.log(\"anim\"+count);\n        \n    }\n    ////\n}\n//animate();\n/////////////\n\n*/\n\n\n    function flipHoriz(drawing){\n        drawing.translate(screenDimensions.width/2,0);\n        drawing.scale(-1, 1);\n    }\n\n\tfunction update(time) {\n        //then = now;\n        now = time;\n        elapsed = now - then;\n        if (elapsed > interval){\n            draw();\n            //console.log(time);\n            then = now;\n        }\n    }\n    function getCanvas(){\n         return hudCanvas;\n    }\n    return {\n        update,\n        getCanvas,\n        draw\n    }\n}","import * as THREE from 'three';\nimport SceneSubject from './SceneSubject';\nimport GeneralLights from './GeneralLights';\nimport { StereoEffect } from './StereoEffect.js';\n//import Hud from './Hud';\nimport Hud from './Hud';\nexport default function canvas(canvas)  {\n    var preserveSize = true;\n\n    const clock = new THREE.Clock();\n    const origin = new THREE.Vector3(0,0,0);\n\n    const screenDimensions = {\n        width: canvas.width,\n        height: canvas.height\n    }\n    \n    const mousePosition = {\n        x: 0,\n        y: 0\n    }\n\n    const scene = buildScene();\n    const renderer = buildRender(screenDimensions);\n    const camera = buildCamera(screenDimensions);\n    const sceneSubjects = createSceneSubjects(scene);\n    var hud = new Hud(scene,canvas);\n    var effect = new StereoEffect( renderer );\n    effect.setSize( screenDimensions.width, screenDimensions.height );\n    effect.setEyeSeparation(0.064);\n    effect.setOffset(0);\n    var offset = 0;\n    \n    scene.add(camera);\n    //console.log(screenDimensions);\n    \n\n    if (preserveSize){\n        // remember these initial values\n        var tanFOV = Math.tan( ( ( Math.PI / 180 ) * camera.fov / 2 ) );\n        var windowHeight = 150;//window.innerHeight;\n    }\n    window.addEventListener(\"keypress\", onKeyPress);\n\n    function getOffset(){\n        const pxMm = 0.254/454;\n        return (screenDimensions.width -300)*pxMm;\n    }\n    function buildScene() {\n        const scene = new THREE.Scene();\n        scene.background = new THREE.Color('black');\n\n        return scene;\n    }\n\n    function buildRender({ width, height }) {\n        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true }); \n        const DPR = window.devicePixelRatio ? window.devicePixelRatio : 1;\n\n        renderer.setPixelRatio(DPR);\n        renderer.setSize(width, height);\n        renderer.autoClear = false;     //needed for canvas2d overlayed\n        renderer.gammaInput = true;\n        renderer.gammaOutput = true; \n        \n        return renderer;\n    }\n\n    function buildCamera({ width, height }) {\n        const aspectRatio = width / height;\n        const fieldOfView = 90;\n        const nearPlane = 0.0001;\n        const farPlane = 20; \n        const camera = new THREE.PerspectiveCamera(fieldOfView, aspectRatio, nearPlane, farPlane);\n        camera.focus = 3;\n        camera.position.set(0, 0, 0);\n\n        return camera;\n    }\n\n    function createSceneSubjects(scene) {\n        const sceneSubjects = [\n            new GeneralLights(scene),\n            new SceneSubject(scene),\n        ];\n        return sceneSubjects;\n    }\n\n\n    function update() {\n        const elapsedTime = clock.getElapsedTime();\n        \n        for(let i=0; i<sceneSubjects.length; i++)\n            sceneSubjects[i].update(elapsedTime);\n        //renderer.render(scene, camera);\n        //console.log(canvas);\n        \n        hud.update(elapsedTime);\n        render();\n        \n        \n    }\n    function render() {\n        //updateCameraPositionRelativeToMouse()\n        effect.render( scene, camera );\n        \n    }\n    function onKeyPress(ev) {\n        let keycode = ev.which;\n        if (\n          (keycode >= 48 && keycode <= 57) ||\n          (keycode >= 97 && keycode <= 122) ||\n          (keycode >= 65 && keycode <= 90)\n        ) {\n            if(keycode == 49) {offset= offset +0.1;effect.setOffset(offset);}\n            if(keycode == 50) {offset = offset -0.1;effect.setOffset(offset);}\n            //if(keycode == 51) {camera.rotateY(Math.PI/360);}\n            //if(keycode == 52) {camera.rotateY(-Math.PI/360);}\n            //console.log( offset);\n            //if(keycode == 51) hud.draw();\n        }\n      }\n\n\n    function updateCameraPositionRelativeToMouse() {\n        camera.position.x += (  (mousePosition.x * 0.1) - camera.position.x ) * 0.1;\n        camera.position.y += ( -(mousePosition.y * 0.1) - camera.position.y ) * 0.1;\n        camera.lookAt(origin );\n    }\n\n    function onWindowResize() {\n        const { width, height } = canvas;\n        \n        screenDimensions.width = width;\n        screenDimensions.height = height;\n\n        camera.aspect = width / height;\n        if (preserveSize){\n            // adjust the FOV\n            camera.fov = ( 360 / Math.PI ) * Math.atan( tanFOV * ( height / windowHeight ) );\n            effect.setOffset(getOffset());\n        }\n\n        camera.updateProjectionMatrix();\n        effect.setSize( width, height);\n        //camera.lookAt( scene.position );\n        renderer.setSize(width, height);   \n    }\n    function getRenderer(){\n        return renderer;\n    }\n\n    function animate(){\n        renderer.setAnimationLoop( function () {\n            \n            //renderer.render( scene, camera );\n            update();\n            \n        } );\n\n    }\n\n    function onMouseMove(x, y) {\n        mousePosition.x = x;\n        mousePosition.y = y;\n    }\n    function getScene(){\n        return scene;\n    }\n    return {\n        update,\n        onWindowResize,\n        onMouseMove,\n        getRenderer,\n        animate,\n        getScene\n    }\n}","import SceneManager from './SceneManager';\n\nexport default container => {\n    \n    const canvas = createCanvas(document, container);\n    const sceneManager = new SceneManager(canvas);\n    \n    \n    let canvasHalfWidth;\n    let canvasHalfHeight;\n\n    bindEventListeners();\n    sceneManager.animate();\n    \n    //var renderer = sceneManager.getRenderer();\n    //render();\n    \n    function createCanvas(document, container) {\n        const canvas = document.createElement(\"canvas\");    \n        container.appendChild(canvas);   \n        return canvas;\n    }\n\n    function bindEventListeners() {\n        window.onresize = resizeCanvas;\n        //window.onmousemove = mouseMove;\n        resizeCanvas();\t\n    }\n\n    function resizeCanvas() {        \n        canvas.style.width = '100%';\n        canvas.style.height= '100%';\n        \n        canvas.width  = canvas.offsetWidth;\n        canvas.height = canvas.offsetHeight;\n\n        canvasHalfWidth = Math.round(canvas.offsetWidth/2);\n        canvasHalfHeight = Math.round(canvas.offsetHeight/2);\n\n        sceneManager.onWindowResize();\n        //hudManager.onWindowResize()\n    }\n\n    function mouseMove({screenX, screenY}) {\n        sceneManager.onMouseMove(screenX-canvasHalfWidth, screenY-canvasHalfHeight);\n    }\n\n    //function render(time) {\n        \n     //   sceneManager.update();\n        //hudManager.update();\n    //    requestAnimationFrame(render);\n    //}/\n    //renderer.setAnimationLoop( function () {\n\n        //renderer.render( scene, camera );\n     //   sceneManager.update();\n    //} );\n\n}\n","import React, { Component } from 'react';\n\nimport threeEntryPoint from \"./threejs/threeEntryPoint\"\nimport \"./viewer.css\"\n\nexport default class Viewer extends Component {\n    \n    componentDidMount() {\n        threeEntryPoint(this.threeRootElement);\n    }\n\n    render () {\n        return (\n            <div className=\"viewer-viewer\" ref={element => this.threeRootElement = element} />\n        );\n    }\n}","import './App.css';\nimport Viewer from './Components/Viewer/Viewer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Viewer />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}